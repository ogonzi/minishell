/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cpeset-c <cpeset-c@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/04/02 19:42:24 by cpeset-c          #+#    #+#             */
/*   Updated: 2023/04/17 18:32:21 by cpeset-c         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "mnshll_utils.h"
#include "mnshll_data.h"
#include "mnshll_error.h"

static void	handle_sig(int sig);
static void	handle_child_sig(int signum);

void	set_sigint_action(void)
/*
 * The code is defining a function set_sigint_action that sets up a signal 
 * handler for the SIGINT signal, which is generated by the terminal when
 * the user presses Ctrl+C while a program is running.
*/
{
	struct sigaction	signal;

	signal.sa_handler = &handle_sig;
	signal.sa_flags = SA_RESTART;
	sigemptyset(&signal.sa_mask);
	if (sigaction(SIGINT, &signal, NULL) < 0)
		terminate(ERR_SIG, EXIT_FAILURE);
}

static void	handle_sig(int sig)
/*
 * This is the function that handles the SIGINT signal that is sent to a
 * process when the user presses Ctrl+C in the terminal. It takes the signal
 * number as an argument and checks if it is equal to SIGINT, which is the
 * signal for interrupting the program.

 * 1.- It prints a newline character "\n" to stdout, to move the cursor to the
 * beginning of a new line.

 * 2.- It calls rl_on_new_line(), which is a function from the GNU Readline 
 * library that moves the cursor to a new line and prepares for a new input
 * prompt.

 * 3.- It calls rl_replace_line() to replace the current input line with an
 * empty string, effectively clearing the line.

 * 4.- It calls rl_redisplay() to display the new input prompt and wait for
 * user input.
*/
{
	if (sig == SIGINT)
	{
		ft_printf_fd(STDOUT_FILENO, "\n");
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

void	set_child_sigaction(void)
/*
 * It declares a variable signal of type struct sigaction, which is a structure
 * used to specify the behavior of a signal.

 * It sets the sa_handler field of signal to handle_child_sig, which is a
 * function that will be called when a signal is received by the child process.

 * It sets the sa_flags field of signal to SA_RESTART. This flag tells the
 * operating system to automatically restart certain system calls that may have
 * been interrupted by a signal.

 * It sets the sa_mask field of signal to an empty set. This specifies the set
 * of signals that should be blocked (i.e., not delivered) while the signal
 * handler is running. In this case, no signals are blocked.

 * It calls sigaction twice with the SIGINT and SIGQUIT signals respectively,
 * and passes in signal as the second argument. If sigaction returns a negative
 * value, it means that an error occurred, so the function exits with an error
 * code.

 * If sigaction succeeds, the signal handlers for SIGINT and SIGQUIT are set to
 * handle_child_sig, and the child process is now ready to handle these signals.
*/
{
	struct sigaction	signal;

	signal.sa_handler = &handle_child_sig;
	signal.sa_flags = SA_RESTART;
	sigemptyset(&signal.sa_mask);
	if (sigaction(SIGINT, &signal, 0) < 0)
		terminate(ERR_SIG, EXIT_FAILURE);
	if (sigaction(SIGQUIT, &signal, 0) < 0)
		terminate(ERR_SIG, EXIT_FAILURE);
}

static void	handle_child_sig(int signum)
{
	if (signum == SIGINT)
	{
		ft_printf_fd(STDOUT_FILENO, "\n");
		exit(TERMINATE_CTRL_C);
	}
	if (signum == SIGQUIT)
	{
		ft_printf_fd(STDOUT_FILENO, "Quit\n");
		rl_on_new_line();
		exit(TERMINATE_QUIT);
	}
}

void	do_sigign(int signum)
{
	struct sigaction	signal;

	signal.sa_handler = SIG_IGN;
	signal.sa_flags = SA_RESTART;
	sigemptyset(&signal.sa_mask);
	if (sigaction(signum, &signal, NULL) < 0)
		terminate(ERR_SIG, EXIT_FAILURE);
}
